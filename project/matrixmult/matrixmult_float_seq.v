//MATRIX MULTIPLICATION USING 1 FP MULTIPLY and 1 FP ADD UNIT (GENERATED BY XILINX COREGEN)
//Written by Ana Klimovic
//March 11, 2013

//counts up to parameter and then resets
module counter(
		input clk,
		input reset,
		input in_ready,			//assert this for one cycle when providing module with fresh input
		output done			//this is asserted when counter reaches N (ie: added all the products for this element of matrix)
		output reg [log2N:0] count
		);

	parameter N = 4; 	//number of rows in matrix (number of additions required to generate one element of matrix result)
	parameter log2N = 2;

	assign done = (count == N) ? 1'b1 : 1'b0;

	always @ (posedge clk)
	begin
		if (reset || done) //done???????????????????????????????????????? --> only want done on for 1 cycle!!!
			begin
				count <= 'b0;
			end
		else if (in_ready && !done) //don't keep adding if done
			begin
				count <= count + 1'b1;
			end
	end
endmodule

//latch matrix result elements and count up to 4 (then you have all elements of result matrix ready)
module latch_matrixmult(
		input clk,
		input reset,
		input [31:0] element_in,
		input new_element,	//need to pulse for one cycle only
		output reg [31:0] element0,
		output reg [31:0] element1,
		output reg [31:0] element2,
		output reg [31:0] element3,
		output reg done_matrix

	);

	reg [2:0] count;

	always @ (posedge clk)
	begin
		if (reset)
			begin 
			element0 <= 32'b0;
			element1 <= 32'b0;
			element2 <= 32'b0;
			element3 <= 32'b0;
			done_matrix <= 1'b0;
			count <= 3'b0;
			end
		else if (new_element && count == 0)	
			begin
			element0 <= element_in;
			count <= count + 1'b1;
			done_matrix <= 1'b0;
			end
		else if (new_element && count == 1)	
			begin
			element1 <= element_in;
			count <= count + 1'b1;
			done_matrix <= 1'b0;
			end
		else if (new_element && count == 2)	
			begin
			element2 <= element_in;
			count <= count + 1'b1;
			done_matrix <= 1'b0;
			end
		else if (new_element && count == 3)	
			begin
			element3 <= element_in;
			count <= count + 1'b1;
			done_matrix <= 1'b1;
			end
	


	end


endmodule

//provide 2 inputs at a time and assert inputs_ready to start, then keep going
module matrixmultiplier (
		input clk,
		input reset,
		input a_tvalid,
		input b_tvalid,
		input [31:0] a,
		input [31:0] b,
		input a_tvalid,
		input b_tvalid,
		output [31:0] result0,
		output [31:0] result1,
		output [31:0] result2,
		output [31:0] result3,
		output done_matrixmult
		);


	wire [31:0] product_tdata;
	wire product_tready;
	wire product_tvalid, product_tuser;
	wire [31:0] element;
	wire element_ready;

	wire add_product_ready, add_b_tready, add_operation_tready, sum_tready, sum_tvalid, sum_tuser;
	wire [4:0] count;

	assign product_tready = 1'b1;
	assign sum_tready = 1'b1;
	
	floating_point_v6_1 fmul (
	  .aclk(clk), // input aclk
	  .s_axis_a_tvalid(a_tvalid), // input s_axis_a_tvalid
	  .s_axis_a_tready(a_tready), // output s_axis_a_tready
	  .s_axis_a_tdata(a), // input [31 : 0] s_axis_a_tdata
	  .s_axis_b_tvalid(b_tvalid), // input s_axis_b_tvalid
	  .s_axis_b_tready(b_tready), // output s_axis_b_tready
	  .s_axis_b_tdata(b), // input [31 : 0] s_axis_b_tdata
	  .m_axis_result_tvalid(product_tvalid), // output m_axis_result_tvalid
	  .m_axis_result_tready(product_tready), // input m_axis_result_tready
	  .m_axis_result_tdata(product_tdata), // output [31 : 0] m_axis_result_tdata
	  .m_axis_result_tuser(product_tuser) // output [2 : 0] m_axis_result_tuser
	);

	

	floating_point_add_sub_v6_1 fadd (
	  .aclk(clk), // input aclk
	  .s_axis_a_tvalid(product_tvalid), // input s_axis_a_tvalid
	  .s_axis_a_tready(add_product_tready), // output s_axis_a_tready
	  .s_axis_a_tdata(product_tdata), // input [31 : 0] s_axis_a_tdata
	  .s_axis_b_tvalid(product_tvalid), // input s_axis_b_tvalid
	  .s_axis_b_tready(add_b_tready), // output s_axis_b_tready
	  .s_axis_b_tdata((count == 4'b0) ? 0 : sum_tdata), // input [31 : 0] s_axis_b_tdata
	  .s_axis_operation_tvalid(1'b1), // input s_axis_operation_tvalid
	  .s_axis_operation_tready(add_operation_tready), // output s_axis_operation_tready
	  .s_axis_operation_tdata(8'b0 /*ADD*/), // input [7 : 0] s_axis_operation_tdata
	  .m_axis_result_tvalid(sum_tvalid), // output m_axis_result_tvalid
	  .m_axis_result_tready(sum_tready), // input m_axis_result_tready
	  .m_axis_result_tdata(sum_tdata), // output [31 : 0] m_axis_result_tdata
	  .m_axis_result_tuser(sum_tuser) // output [2 : 0] m_axis_result_tuser
	);

	//note: there might be an issue with one cycle delay of count to get to input mux of
	//fadd!!!!!!!!!!!!!---> check this in simulation!!!!!!!!!!!!!!!!!!!!!!	
	counter count_dot_product_elements(
		.clk(clk),
		.reset(reset),
		.in_ready(product_tready),//assert this for one cycle when providing module with fresh input
		.done(element_ready),
		.count(count)
		);

 	latch_matrixmult latch(
		.clk(clk),
		.reset(reset),
		.element_in(sum_tdata),
		.new_element(element_ready),	//need to pulse for one cycle only
		.element0(result0),
		.element1(result1),
		.element2(result2),
		.element3(result3),
		.done_matrix(done_matrixmult)
		);

endmodule

////////////////////////////////////////////////////////




module matrixmult_tb();

   wire [15:0] row0_0;
	wire [15:0] row0_1;
	wire [15:0] row0_2;
	wire [15:0] row0_3;

	wire [15:0] row1_0;
	wire [15:0] row1_1;
	wire [15:0] row1_2;
	wire [15:0] row1_3;

	wire [15:0] row2_0;
	wire [15:0] row2_1;
	wire [15:0] row2_2;
	wire [15:0] row2_3;

	wire [15:0] row3_0;
	wire [15:0] row3_1;
	wire [15:0] row3_2;
	wire [15:0] row3_3;

	wire [15:0] pixelinT_0; 	//transpose of pixel
	wire [15:0] pixelinT_1;
	wire [15:0] pixelinT_2;
	wire [15:0] pixelinT_3;

	wire [31:0] pixelout_0;
	wire [31:0] pixelout_1;
	wire [31:0] pixelout_2;
	wire [31:0] pixelout_3;



   assign row0_0 = 16'd1;
	assign row0_1 = 16'd1;
	assign row0_2 = 16'd2;
	assign row0_3 = 16'd3;

	assign row1_0 = 16'd5;
	assign row1_1 = 16'd6;
	assign row1_2 = 16'd7;
	assign row1_3 = 16'd3;

	assign row2_0 = 16'd1;
	assign row2_1 = 16'd2;
	assign row2_2 = 16'd3;
	assign row2_3 = 16'd2;

	assign row3_0 = 16'd4;
	assign row3_1 = 16'd5;
	assign row3_2 = 16'd3;
	assign row3_3 = 16'd5;

	assign pixelinT_0 = 16'd2; 	//transpose of pixel
	assign pixelinT_1 = 16'd5;
	assign pixelinT_2 = 16'd3;
	assign pixelinT_3 = 16'd1;




	matrixmult dut(
			.row0_0(row0_0),
			.row0_1(row0_1),
			.row0_2(row0_2),
			.row0_3(row0_3),

			.row1_0(row1_0),
			.row1_1(row1_1),
			.row1_2(row1_2),
			.row1_3(row1_3),

			.row2_0(row2_0),
			.row2_1(row2_1),
			.row2_2(row2_2),
			.row2_3(row2_3),

			.row3_0(row3_0),
			.row3_1(row3_1),
			.row3_2(row3_2),
			.row3_3(row3_3),

			.pixelinT_0(pixelinT_0),
			.pixelinT_1(pixelinT_1),
			.pixelinT_2(pixelinT_2),
			.pixelinT_3(pixelinT_3),

			.pixelout_0(pixelout_0),
			.pixelout_1(pixelout_1),
			.pixelout_2(pixelout_2),
			.pixelout_3(pixelout_3)

		);

endmodule


module matrixmult 
(
	input [15:0] row0_0,
	input [15:0] row0_1,
	input [15:0] row0_2,
	input [15:0] row0_3,

	input [15:0] row1_0,
	input [15:0] row1_1,
	input [15:0] row1_2,
	input [15:0] row1_3,

	input [15:0] row2_0,
	input [15:0] row2_1,
	input [15:0] row2_2,
	input [15:0] row2_3,

	input [15:0] row3_0,
	input [15:0] row3_1,
	input [15:0] row3_2,
	input [15:0] row3_3,

	input [15:0] pixelinT_0, 	//transpose of pixel
	input [15:0] pixelinT_1,
	input [15:0] pixelinT_2,
	input [15:0] pixelinT_3,

	output [31:0] pixelout_0,
	output [31:0] pixelout_1,
	output [31:0] pixelout_2,
	output [31:0] pixelout_3


);


assign pixelout_0 = (row0_3 * pixelinT_3) + (row0_2 * pixelinT_2) + (row0_1 * pixelinT_1) + (row0_0 * pixelinT_0);
assign pixelout_1 = (row1_3 * pixelinT_3) + (row1_2 * pixelinT_2) + (row1_1 * pixelinT_1) + (row1_0 * pixelinT_0);
assign pixelout_2 = (row2_3 * pixelinT_3) + (row2_2 * pixelinT_2) + (row2_1 * pixelinT_1) + (row2_0 * pixelinT_0);
assign pixelout_3 = (row3_3 * pixelinT_3) + (row3_2 * pixelinT_2) + (row3_1 * pixelinT_1) + (row3_0 * pixelinT_0);


endmodule


